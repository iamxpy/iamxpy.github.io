<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="javase,NIO," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="概述Channel用于在字节缓冲区和位于通道另一侧的实体（通常是一个文件或套接字）之间有效地传输数据。多数情况下，Channel与操作系统的文件描述符(File Descriptor)和文件句柄(File Handle)有着一对一的关系。通道是一种途径，借助该途径，可以用最小的总开销来访问操作系统本身的I/O服务。缓冲区则是通道内部用来发送和接收数据的端点。下图中的箭头展示了channel在连接I">
<meta name="keywords" content="javase,NIO">
<meta property="og:type" content="article">
<meta property="og:title" content="Java NIO 学习之Channel">
<meta property="og:url" content="http://yoursite.com/2017/04/26/Java-NIO-学习之Channel/index.html">
<meta property="og:site_name" content="Gene's Home">
<meta property="og:description" content="概述Channel用于在字节缓冲区和位于通道另一侧的实体（通常是一个文件或套接字）之间有效地传输数据。多数情况下，Channel与操作系统的文件描述符(File Descriptor)和文件句柄(File Handle)有着一对一的关系。通道是一种途径，借助该途径，可以用最小的总开销来访问操作系统本身的I/O服务。缓冲区则是通道内部用来发送和接收数据的端点。下图中的箭头展示了channel在连接I">
<meta property="og:image" content="http://yoursite.com/images/channel-service.png">
<meta property="og:image" content="http://yoursite.com/images/scatter-read.png">
<meta property="og:image" content="http://yoursite.com/images/four-gather.png">
<meta property="og:image" content="http://yoursite.com/images/four-scatter.png">
<meta property="og:image" content="http://yoursite.com/images/io-api-comparation.png">
<meta property="og:image" content="http://yoursite.com/images/channel-pipe.png">
<meta property="og:image" content="http://yoursite.com/images/finishConnect.png">
<meta property="og:updated_time" content="2017-05-13T14:47:23.952Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java NIO 学习之Channel">
<meta name="twitter:description" content="概述Channel用于在字节缓冲区和位于通道另一侧的实体（通常是一个文件或套接字）之间有效地传输数据。多数情况下，Channel与操作系统的文件描述符(File Descriptor)和文件句柄(File Handle)有着一对一的关系。通道是一种途径，借助该途径，可以用最小的总开销来访问操作系统本身的I/O服务。缓冲区则是通道内部用来发送和接收数据的端点。下图中的箭头展示了channel在连接I">
<meta name="twitter:image" content="http://yoursite.com/images/channel-service.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/04/26/Java-NIO-学习之Channel/"/>





  <title> Java NIO 学习之Channel | Gene's Home </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Gene's Home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/26/Java-NIO-学习之Channel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gene">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/gene.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gene's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Java NIO 学习之Channel
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-26T22:14:15+08:00">
                2017-04-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/04/26/Java-NIO-学习之Channel/" class="leancloud_visitors" data-flag-title="Java NIO 学习之Channel">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Channel用于在字节缓冲区和位于通道另一侧的实体（通常是一个文件或套接字）之间有效地传输数据。多数情况下，Channel与操作系统的文件描述符(File Descriptor)和文件句柄(File Handle)有着一对一的关系。通道是一种途径，借助该途径，可以用最小的总开销来访问操作系统本身的I/O服务。缓冲区则是通道内部用来发送和接收数据的端点。下图中的箭头展示了channel在连接IO服务的时充当的角色<br><a id="more"></a><br><img src="/images/channel-service.png" alt="channel-service-in-IO"><br>有两种类型的Channel：<br>文件通道，对应FileChannel类<br>套接字通道，对应SocketChannel、 ServerSocketChannel 和 DatagramChannel类</p>
<h2 id="概念与原理"><a href="#概念与原理" class="headerlink" title="概念与原理"></a>概念与原理</h2><h3 id="Scatter-Gather"><a href="#Scatter-Gather" class="headerlink" title="Scatter/Gather"></a>Scatter/Gather</h3><p>Scatter/Gather是一个简单却强大的概念，也称为矢量IO，大多数现代操作系统都支持本地矢量IO。当我们在一个通道上请求一个Scatter或Gather操作时，该请求会被翻译为适当的本地调用来直接填充或抽取缓冲区</p>
<p><img src="/images/scatter-read.png" alt="scatter-read.png"></p>
<blockquote>
<p>关于图中DMA，用户空间，内核空间等概念，可以参考<a href="https://iamxpy.github.io/2017/04/24/Java-NIO-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86/" target="_blank" rel="external">Java NIO 学习之背景知识</a></p>
</blockquote>
<p>如上图所示，进程只需一个系统调用，就能把一连串缓冲区地址传递给操作系统。然后，内核就可以顺序填充或排干多个缓冲区，读的时候就把数据发散到多个用户空间缓冲区，写的时候再从多个缓冲区把数据汇聚起来。这样,用户进程就不必多次执行系统调用（那样做可能代价不菲），内核也可以优化数据的处理过程，因为它已掌握待传输数据的全部信息。如果系统配有多个CPU，甚至可以同时填充或排干多个缓冲区。</p>
<p>在NIO中，Scatter/Gatter的相关API是channel的数组形式的read和write操作，如read(ByteBuffer[] dsts)和write(ByteBuffer[] srcs)等，下面分别用图示解释这两种操作的数据移动的结果：下图描述了一个gather写操作。数据从缓冲区阵列引用的每个缓冲区中gather并被组合成沿着通道发送的字节流。</p>
<p><img src="/images/four-gather.png" alt="four-gather.png"></p>
<p>描述了一个 scatter 读操作。从通道传输来的数据被scatter到所列缓冲区，依次填充每个缓冲区（从缓冲区的position处开始到limit处结束）。这里显示的position和limit值是读操作开始之前的。</p>
<p><img src="/images/four-scatter.png" alt="four-scatter.png"></p>
<h3 id="文件通道"><a href="#文件通道" class="headerlink" title="文件通道"></a>文件通道</h3><p>每个FileChannel对象都同一个文件描述符有一对一的关系，在FileChannel出现之前，底层的文件操作都是通过RandomAccessFile类的方法来实现的。FileChannel模拟同样的I/O服务，因此它们的API自然也是很相似的。为了便于比较，下图列出了FileChannel，RandomAccessFile和POSIX I/O系统调用在方法上的对应关系</p>
<p><img src="/images/io-api-comparation.png" alt="io-api-comparation.png"></p>
<p>同底层的文件描述符一样，每个FileChannel都有一个叫position的概念。这个position值决定文件中哪一处的数据接下来将被读或者写。position是从底层的文件描述符获得的，该position同时被作为通道引用获取来源的文件对象共享，这也就意味着一个对象对该position的更新可以被另一个对象看到。</p>
<p>类似于缓冲区的get()和put()方法，当字节被read()或write()方法传输时，文件position会自动更新。如果position达到了文件大小的值（文件大小的值可以通过size()方法返回），read()方法会返回-1。可是，不同于缓冲区的是，如果使用write()方法时position前进到超过文件大小的值，该文件会扩展以容纳新写入的字节。</p>
<h3 id="获取通道的几种方法"><a href="#获取通道的几种方法" class="headerlink" title="获取通道的几种方法"></a>获取通道的几种方法</h3><p>1.调用支持通道的类的getChannel()方法<br>本地IO：FileInputStream/FileOutputStream、RandomAccessFile<br>网络IO：Socket、ServerSocket 、DatagramSocket</p>
<blockquote>
<p>Socket的相关类调用getChannel()不会创建新的通道，只会返回与之对应的channel。意思是，如果先实例化来创建Socket，然后调用getCahnnel则会返回null，而先创建SocketChannel，调用其socket()方法得到socket后，在此socket上调用getChannel才会返回与之对应的channel</p>
</blockquote>
<p>2.调用各个通道的静态方法open()</p>
<p>3.调用Files工具类的newByteChannel()</p>
<p>4.调用Channels.newChannel(InputStream in)或Channels.newChannel(OutputStream out)</p>
<h3 id="文件锁定"><a href="#文件锁定" class="headerlink" title="文件锁定"></a>文件锁定</h3><p>在不同的操作系统上，甚至在同一个操作系统的不同文件系统上，文件锁定的语义都会有所差异。我们应该总是按照劝告锁的假定来管理文件锁，因为这是最安全的。文件锁类型的区别见<a href="https://iamxpy.github.io/2017/04/24/Java-NIO-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86/" target="_blank" rel="external">Java NIO 学习之背景知识</a></p>
<p>如果一个线程在某个文件上获得了一个独占锁，然后第二个线程利用一个单独打开的通道来请求该文件的独占锁，那么第二个线程的请求会被批准。但如果这两个线程运行在不同的 Java 虚拟机上，那么第二个线程会阻塞，因为锁最终是由操作系统或文件系统来判优的并且几乎总是在进程级而非线程级上判优。锁都是与一个文件关联的，而不是与单个的文件句柄或通道关联</p>
<p>FileLock推荐使用形式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">FileLock lock = fileChannel.lock();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="comment">//perform read/write/whatever on channel</span></div><div class="line">&#125; <span class="keyword">catch</span>(IOException e)&#123;</div><div class="line"><span class="comment">//handle unexpected exception</span></div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">lock.release();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="管道Pipe"><a href="#管道Pipe" class="headerlink" title="管道Pipe"></a>管道Pipe</h2><p>用于线程间通信。Pipe类定义了两个嵌套的通道类，这两个类是Pipe.SourceChannel（管道负责读的一端）和 Pipe.SinkChannel（管道负责写的一端），如下图所示</p>
<p><img src="/images/channel-pipe.png" alt="channel-pipe.png"></p>
<p>这两个通道实例是在Pipe对象创建的同时被创建的，可以通过在Pipe对象上分别调用source( )和sink( )方法来取回。管道可以被用来仅在同一个Java虚拟机内部传输数据。虽然有更加有效率的方式来在线程之间传输数据，但是使用管道的好处在于封装性。生产者线程和用户线程都能被写道通用的Channel API中。根据给定的通道类型，相同的代码可以被用来写数据到一个文件、socket或管道。选择器可以被用来检查管道上的数据可用性，如同在socket通道上使用那样地简单。这样就可以允许单个用户线程使用一个Selector来从多个通道有效地收集数据，并可任意结合网络连接或本地工作线程使用。因此，这些对于可伸缩性、冗余度以及可复用性来说无疑都是意义重大的。</p>
<h2 id="Channel通用API"><a href="#Channel通用API" class="headerlink" title="Channel通用API"></a>Channel通用API</h2><h3 id="read-ByteBuffer-dst"><a href="#read-ByteBuffer-dst" class="headerlink" title="read(ByteBuffer dst)"></a>read(ByteBuffer dst)</h3><p>从channel中读取数据到dst中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*来自ReadableByteChannel的注释</span></div><div class="line"> *A read operation might not fill the buffer, and in fact it might not</div><div class="line"> *read any bytes at all.  Whether or not it does so depends upon the</div><div class="line"> *nature and state of the channel.  A socket channel in non-blocking mode,</div><div class="line"> *for example, cannot read any more bytes than are immediately available</div><div class="line"> *from the socket's input buffer; similarly, a file channel cannot read</div><div class="line"> *any more bytes than remain in the file.  It is guaranteed, however, that</div><div class="line"> *if a channel is in blocking mode and there is at least one byte</div><div class="line"> *remaining in the buffer then this method will block until at least one</div><div class="line"> *byte is read.</div><div class="line"> */</div></pre></td></tr></table></figure>
<h3 id="read-ByteBuffer-dsts"><a href="#read-ByteBuffer-dsts" class="headerlink" title="read(ByteBuffer[] dsts)"></a>read(ByteBuffer[] dsts)</h3><p>对dsts中的所有ByteBuffer执行gather操作</p>
<h3 id="read-ByteBuffer-dsts-int-offset-int-length"><a href="#read-ByteBuffer-dsts-int-offset-int-length" class="headerlink" title="read(ByteBuffer[] dsts, int offset, int length)"></a>read(ByteBuffer[] dsts, int offset, int length)</h3><p>对dsts中的部分ByteBuffer执行gather操作。offset参数是指哪个缓冲区将开始被使用，而不是指数据的 offset。length参数指示要使用的缓冲区数量。</p>
<h3 id="write-ByteBuffer-src"><a href="#write-ByteBuffer-src" class="headerlink" title="write(ByteBuffer src)"></a>write(ByteBuffer src)</h3><p>将src中的数据写入到channel中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*来自WritableByteChannel的注释</span></div><div class="line"> *An attempt is made to write up to r bytes to the channel,</div><div class="line"> *where r is the number of bytes remaining in the buffer, that is,</div><div class="line"> *src.remaining(), at the moment this method is invoked.</div><div class="line"> *Unless otherwise specified, a write operation will return only after</div><div class="line"> *writing all of the r requested bytes.  Some types of channels,</div><div class="line"> *depending upon their state, may write only some of the bytes or possibly</div><div class="line"> *none at all.  A socket channel in non-blocking mode, for example, cannot</div><div class="line"> *write any more bytes than are free in the socket's output buffer.</div><div class="line"> */</div></pre></td></tr></table></figure>
<h3 id="write-ByteBuffer-srcs"><a href="#write-ByteBuffer-srcs" class="headerlink" title="write(ByteBuffer[] srcs)"></a>write(ByteBuffer[] srcs)</h3><p>对srcs中的所有ByteBuffer执行scatter操作</p>
<blockquote>
<p>使用<code>while (channel.write(bs) &gt; 0){}</code>来确保已经将srcs中所有buffer的有效数据都被写入channel</p>
</blockquote>
<h3 id="write-ByteBuffer-srcs-int-offset-int-length"><a href="#write-ByteBuffer-srcs-int-offset-int-length" class="headerlink" title="write(ByteBuffer[] srcs, int offset, int length)"></a>write(ByteBuffer[] srcs, int offset, int length)</h3><p>对srcs中的部分ByteBuffer执行scatter操作。offset参数是指哪个缓冲区将开始被使用，而不是指数据的 offset。length参数指示要使用的缓冲区数量。</p>
<p><strong>下面是实现通道之间复制数据的代码，代码中的两个循环条件是经常被使用的</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">channelCopy2</span> <span class="params">(ReadableByteChannel src,</span></span></div><div class="line">WritableByteChannel dest)</div><div class="line"><span class="keyword">throws</span> IOException</div><div class="line">&#123;</div><div class="line">ByteBuffer buffer = ByteBuffer.allocateDirect (<span class="number">16</span> * <span class="number">1024</span>);</div><div class="line"><span class="keyword">while</span> (src.read (buffer) != -<span class="number">1</span>) &#123;</div><div class="line"><span class="comment">// Prepare the buffer to be drained</span></div><div class="line">buffer.flip( );</div><div class="line"><span class="comment">// Make sure that the buffer was fully drained</span></div><div class="line"><span class="keyword">while</span> (buffer.hasRemaining( )) &#123;</div><div class="line">dest.write (buffer);</div><div class="line">&#125;</div><div class="line"><span class="comment">// Make the buffer empty, ready for filling</span></div><div class="line">buffer.clear( );</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="文件通道独有API"><a href="#文件通道独有API" class="headerlink" title="文件通道独有API"></a>文件通道独有API</h2><h3 id="position"><a href="#position" class="headerlink" title="position()"></a>position()</h3><p>返回当前文件通道的position值</p>
<h3 id="position-long-newPosition"><a href="#position-long-newPosition" class="headerlink" title="position(long newPosition)"></a>position(long newPosition)</h3><p>将文件通道的position设置为指定值</p>
<h3 id="read-ByteBuffer-dst-long-position"><a href="#read-ByteBuffer-dst-long-position" class="headerlink" title="read(ByteBuffer dst, long position)"></a>read(ByteBuffer dst, long position)</h3><p>在文件通道的position处开始读取</p>
<h3 id="write-ByteBuffer-src-long-position"><a href="#write-ByteBuffer-src-long-position" class="headerlink" title="write(ByteBuffer src, long position)"></a>write(ByteBuffer src, long position)</h3><p>在文件通道的position处开始写入</p>
<h3 id="truncate-long-size"><a href="#truncate-long-size" class="headerlink" title="truncate(long size)"></a>truncate(long size)</h3><p>将文件截断至指定大小</p>
<h3 id="force-boolean-metaData"><a href="#force-boolean-metaData" class="headerlink" title="force(boolean metaData)"></a>force(boolean metaData)</h3><p>告诉通道强制将全部待定的修改都应用到磁盘的文件上。布尔型参数metaData表示在方法返回值前，文件的元数据是否也要被同步更新到磁盘。<br>所有的现代文件系统都会缓存数据和延迟磁盘文件更新以提高性能。调用force()方法要求文件的所有待定修改立即同步到磁盘。如果文件位于一个本地文件系统，那么一旦方法返回，即可保证从通道被创建或上次调用 force()时起的对文件所做的全部修改已经被写入到磁盘。对于关键操作如事务处理来说，这一点是非常重要的，可以保证数据完整性和可靠的恢复。</p>
<h3 id="lock-long-position-long-size-boolean-shared"><a href="#lock-long-position-long-size-boolean-shared" class="headerlink" title="lock(long position, long size, boolean shared)"></a>lock(long position, long size, boolean shared)</h3><p>指定文件内部锁定区域的开始position以及锁定区域的size。第三个参数 shared 表示想获取的锁是共享的还是独占的要获得一个共享锁，必须先以只读权限打开文件，而请求独占锁时则需要写权限。锁定区域的范围不一定要限制在文件的size值以内，锁可以扩展从而超出文件尾。因此，我们可以提前把待写入数据的区域锁定，我们也可以锁定一个不包含任何文件内容的区域，比如文件最后一个字节以外的区域。如果之后文件增长到达那块区域，那么文件锁就可以保护该区域的文件内容了。相反地，如果锁定了文件的某一块区域，然后文件增长超出了那块区域，那么新增加的文件内容将不会受到文件锁的保护</p>
<h3 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h3><p>等价于<code>fileChannel.lock (0L, Long.MAX_VALUE, false);</code>，这是在整个文件上请求独占锁的便捷方法，锁定区域等于它能达到的最大范围</p>
<blockquote>
<p>如果请求的锁定范围是有效的，那么lock()方法会阻塞，它必须等待前面的锁被释放</p>
</blockquote>
<h3 id="tryLock-与tryLock-long-position-long-size-boolean-shared"><a href="#tryLock-与tryLock-long-position-long-size-boolean-shared" class="headerlink" title="tryLock()与tryLock(long position, long size, boolean shared)"></a>tryLock()与tryLock(long position, long size, boolean shared)</h3><p>lock()方法的非阻塞形式，如果请求的锁不能立即获得则会返回null</p>
<h3 id="map-MapMode-mode-long-position-long-size"><a href="#map-MapMode-mode-long-position-long-size" class="headerlink" title="map(MapMode mode, long position, long size)"></a>map(MapMode mode, long position, long size)</h3><p>在一个打开的文件和一个MappedByteBuffer之间建立一个虚拟内存映射。position和size参数的含义与lock()中的参数含义相同，但size不应超过文件大小，否则会造成文件空洞。mode参数指定文件映射的模式，使用FileChannel类的内部类MapMode静态字段指定，共有三种模式：<code>READ_ONLY</code>，<code>READ_WRITE</code>，<code>PRIVATE</code>。</p>
<p><code>MapMode.PRIVATE</code>表示一个写时拷贝(copy-on-write)的映射。这意味着通过 put()方法所做的任何修改都会导致产生一个私有的数据拷贝并且该拷贝中的数据只有MappedByteBuffer实例可以看到。该过程不会对底层文件做任何修改，而且一旦缓冲区被施以垃圾收集动作，那些修改都会丢失。选择使用 MapMode.PRIVATE模式并不会导致得到的缓冲区看不到通过其他方式对文件所做的修改，对文件某个区域的修改在使用MapMode.PRIVATE模式的缓冲区中都能反映出来，除非该缓冲区已经修改了文件上的同一个区域。内存和文件系统都被划分成了页。当在一个写时拷贝的缓冲区上调用 put()方法时，受影响的页会被拷贝，然后更改就会应用到该拷贝中。具体的页面大小取决于具体实现，不过通常都是和底层文件系统的页面大小时一样的。如果缓冲区还没对某个页做出修改，那么这个页就会反映被映射文件的相应位置上的内容。一旦某个页因为写操作而被拷贝，之后就将使用该拷贝页，并且不能被其他缓冲区或文件更新所修改</p>
<blockquote>
<p>虚拟内存映射的概念见<a href="https://iamxpy.github.io/2017/04/24/Java-NIO-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86/" target="_blank" rel="external">Java NIO 学习之背景知识</a></p>
</blockquote>
<h3 id="transferTo-和transferFrom"><a href="#transferTo-和transferFrom" class="headerlink" title="transferTo()和transferFrom()"></a>transferTo()和transferFrom()</h3><p>在Channel与Channel之间传递数据而不需要通过Buffer。直接的通道传输不会更新与某个 FileChannel关联的position 值。请求的数据传输将从position参数指定的位置开始，传输的字节数不超过count参数的值。实际传输的字节数会由方法返回，可能少于请求的字节数。socket通道没有该方法，意味着不能用该API在socket通道之间传递数据，不过socket通道实现了WritableByteChannel和ReadableByteChannel接口，因此文件的内容可以用transferTo()方法传输给一个socket通道，或者也可以用transferFrom()方法将数据从一个socket通道直接读取到一个文件中。</p>
<h2 id="FileLock相关API"><a href="#FileLock相关API" class="headerlink" title="FileLock相关API"></a>FileLock相关API</h2><h3 id="channel"><a href="#channel" class="headerlink" title="channel()"></a>channel()</h3><p>返回创建这个文件锁的通道</p>
<h3 id="release"><a href="#release" class="headerlink" title="release()"></a>release()</h3><p>释放一个文件锁</p>
<blockquote>
<p>建议在finally中调用</p>
</blockquote>
<h3 id="isValid"><a href="#isValid" class="headerlink" title="isValid()"></a>isValid()</h3><p>测试一个锁是否有效。一个锁在release()方法被调用或它所关联的通道被关闭或Java虚拟机关闭时会失效</p>
<h3 id="isShared"><a href="#isShared" class="headerlink" title="isShared()"></a>isShared()</h3><p>测试一个锁是共享的还是独占的</p>
<blockquote>
<p>如果底层的操作系统或文件系统不支持共享锁，那么该方法将总是返回false值，即使申请锁时传递的参数值是true</p>
</blockquote>
<h2 id="Socket通道独有API"><a href="#Socket通道独有API" class="headerlink" title="Socket通道独有API"></a>Socket通道独有API</h2><h3 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h3><p>打开一个socket通道</p>
<h3 id="open-SocketAddress-remote"><a href="#open-SocketAddress-remote" class="headerlink" title="open(SocketAddress remote)"></a>open(SocketAddress remote)</h3><p>等价于先open()，再connect到remote地址</p>
<h3 id="socket"><a href="#socket" class="headerlink" title="socket()"></a>socket()</h3><p>返回此socket通道的对等socket</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//给ServerSocket绑定地址的常用方法</span></div><div class="line">ServerSocketChannel ssc = ServerSocketChannel.open( );</div><div class="line">ServerSocket serverSocket = ssc.socket( );</div><div class="line"><span class="comment">// Listen on port 1234</span></div><div class="line">serverSocket.bind (<span class="keyword">new</span> InetSocketAddress (<span class="number">1234</span>));</div><div class="line"></div><div class="line"><span class="comment">//下面是UDP Socket的绑定做法</span></div><div class="line">DatagramChannel channel = DatagramChannel.open( );</div><div class="line">DatagramSocket socket = channel.socket( );</div><div class="line">socket.bind (<span class="keyword">new</span> InetSocketAddress (portNumber));</div></pre></td></tr></table></figure>
<h3 id="accept"><a href="#accept" class="headerlink" title="accept()"></a>accept()</h3><p>返回一个SocketChannel对象，如果处于非阻塞模式，当没有连接在等待时，立即返回null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//非阻塞模式的accept()方法的使用</span></div><div class="line">ServerSocketChannel ssc = ServerSocketChannel.open( );</div><div class="line">ssc.socket( ).bind (<span class="keyword">new</span> InetSocketAddress (port));</div><div class="line">ssc.configureBlocking (<span class="keyword">false</span>);</div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    System.out.println (<span class="string">"Waiting for connections"</span>);</div><div class="line">    SocketChannel sc = ssc.accept( );</div><div class="line">    <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">// no connections, snooze a while</span></div><div class="line">        Thread.sleep (<span class="number">2000</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.out.println (<span class="string">"Incoming connection from: "</span></div><div class="line">                + sc.socket().getRemoteSocketAddress( ));</div><div class="line">            buffer.rewind( );</div><div class="line">            sc.write (buffer);</div><div class="line">            sc.close( );</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="configureBlocking-boolean-block"><a href="#configureBlocking-boolean-block" class="headerlink" title="configureBlocking(boolean block)"></a>configureBlocking(boolean block)</h3><p>设置通道是否阻塞</p>
<h3 id="isBlocking"><a href="#isBlocking" class="headerlink" title="isBlocking()"></a>isBlocking()</h3><p>测试通道当前是否处于阻塞模式</p>
<blockquote>
<p>只有面向流的通道才可以设置非阻塞模式，例如socket通道，Pipe里面的通道</p>
</blockquote>
<h3 id="blockingLock"><a href="#blockingLock" class="headerlink" title="blockingLock()"></a>blockingLock()</h3><p>该方法会返回一个非透明的对象引用。只有拥有此对象的锁的线程才能更改通道的阻塞模式。可以确保在执行代码的关键部分时socket通道的阻塞模式不会改变以及在不影响其他线程的前提下暂时改变阻塞模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Socket socket = <span class="keyword">null</span>;</div><div class="line">Object lockObj = serverChannel.blockingLock( );</div><div class="line"><span class="comment">// have a handle to the lock object, but haven't locked it yet</span></div><div class="line"><span class="comment">// may block here until lock is acquired</span></div><div class="line">synchronize (lockObj)   </div><div class="line">&#123;</div><div class="line"><span class="comment">// This thread now owns the lock; mode can't be changed</span></div><div class="line"><span class="keyword">boolean</span> prevState = serverChannel.isBlocking( );</div><div class="line">serverChannel.configureBlocking (<span class="keyword">false</span>);</div><div class="line">socket = serverChannel.accept( );</div><div class="line">serverChannel.configureBlocking (prevState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="connect-SocketAddress-remote"><a href="#connect-SocketAddress-remote" class="headerlink" title="connect(SocketAddress remote)"></a>connect(SocketAddress remote)</h3><p>作用与socket的connect(SocketAddress endpoint)相同</p>
<blockquote>
<p>SocketChannel与DatagramChannel都有connect方法，对于DatagramChannel来说，将其置于已连接的状态可以使除了它所“连接”到的地址之外的任何其他源地址的数据报被忽略。这是很有帮助的，因为不想要的包都已经被网络层丢弃了，从而避免了使用代码来接收、检查然后丢弃包的麻烦。当DatagramChannel已连接时，使用同样的令牌，你不可以发送包到除了指定给connect()方法的目的地址以外的任何其他地址，否则会导致<code>SecurityException</code>异常</p>
<p>当一个DatagramChannel处于已连接状态时，发送数据将不用提供目的地址而且接收时的源地址也是已知的。这意味着 DatagramChannel 已连接时可以使用常规的read( )和write( )方法，包括scatter/gather 形式的读写来组合或分拆包的数据</p>
</blockquote>
<h3 id="isConnected"><a href="#isConnected" class="headerlink" title="isConnected()"></a>isConnected()</h3><p>测试是否已经完成连接<strong>（与finishConnect()的区别？？？）</strong></p>
<blockquote>
<p>The connect( ) and finishConnect( ) methods are mutually synchronized, and any read or write calls will block while one of these operations is in progress, even in nonblocking mode. Test the connection state with isConnected( ) if there’s any doubt or if you can’t afford to let a read or write block on a channel in this circumstance connect( )和 finishConnect( )<br>不明白这段话的含义。。。不过好像间接说明了isConnected()与finishConnect()的区别</p>
</blockquote>
<h3 id="isConnectPending"><a href="#isConnectPending" class="headerlink" title="isConnectPending()"></a>isConnectPending()</h3><p>测试是否处于连接等待阶段</p>
<h3 id="finishConnect"><a href="#finishConnect" class="headerlink" title="finishConnect()"></a>finishConnect()</h3><p>测试是否已经完成连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//常见用法</span></div><div class="line"><span class="keyword">while</span> ( ! sc.finishConnect( )) &#123;</div><div class="line">doSomethingElse( );</div><div class="line">&#125;</div><div class="line">doSomethingWithChannel (sc);</div></pre></td></tr></table></figure>
<p>下面的示意图解释了连接建立的阶段以及finishConnect()方法调用的结果<br><img src="/images/finishConnect.png" alt="finishConnect.png"></p>
<h3 id="send-ByteBuffer-src-SocketAddress-target"><a href="#send-ByteBuffer-src-SocketAddress-target" class="headerlink" title="send(ByteBuffer src, SocketAddress target)"></a>send(ByteBuffer src, SocketAddress target)</h3><p>发送给定 ByteBuffer 对象的内容到给定SocketAddress对象所描述的目的地址和端口，内容范围为从当前position开始到limit处结束。如果DatagramChannel对象处于阻塞模式，调用线程可能会休眠直到数据报被加入传输队列。如果通道是非阻塞的，返回值要么是字节缓冲区的字节数，要么是“0”。发送数据报是一个全有或全无（all-or-nothing）的行为。如果传输队列没有足够空间来承载整个数据报，那么什么内容都不会被发送</p>
<h3 id="receive-ByteBuffer-dst"><a href="#receive-ByteBuffer-dst" class="headerlink" title="receive(ByteBuffer dst)"></a>receive(ByteBuffer dst)</h3><p>将传入的数据报的数据复制到ByteBuffer中并返回一个SocketAddress对象以指出数据来源。如果通道处于阻塞模式，receive()会阻塞直到有包到达。如果是非阻塞模式，当没有可接收的包时则会返回null。假如提供的ByteBuffer没有足够的剩余空间来存放正在接收的数据包，没有被填充的字节都会被悄悄地丢弃</p>
<h3 id="disconnect"><a href="#disconnect" class="headerlink" title="disconnect()"></a>disconnect()</h3><p>断开对等的socket的连接</p>
<blockquote>
<p>不同于SocketChannel（必须连接了才有用并且只能连接一次），DatagramChannel对象可以任意次数地进行连接或断开连接。每次连接都可以到一个不同的远程地址</p>
</blockquote>
<h2 id="Pipe类API"><a href="#Pipe类API" class="headerlink" title="Pipe类API"></a>Pipe类API</h2><h3 id="open-1"><a href="#open-1" class="headerlink" title="open()"></a>open()</h3><p>创建一个Pipe实例</p>
<h3 id="source"><a href="#source" class="headerlink" title="source()"></a>source()</h3><p>返回对应的source通道</p>
<h3 id="sink"><a href="#sink" class="headerlink" title="sink()"></a>sink()</h3><p>返回对应的sink通道</p>
<h2 id="Channels类API"><a href="#Channels类API" class="headerlink" title="Channels类API"></a>Channels类API</h2><h3 id="newChannel-InputStream-in"><a href="#newChannel-InputStream-in" class="headerlink" title="newChannel(InputStream in)"></a>newChannel(InputStream in)</h3><p>返回一个将从给定的输入流读取数据的通道</p>
<h3 id="newChannel-OutputStream-out"><a href="#newChannel-OutputStream-out" class="headerlink" title="newChannel(OutputStream out)"></a>newChannel(OutputStream out)</h3><p>返回一个将向给定的输出流写入数据的通道</p>
<blockquote>
<p>Channels类的方法常见用于包装标准输入输出流，即System.in和System.out</p>
</blockquote>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/javase/" rel="tag"># javase</a>
          
            <a href="/tags/NIO/" rel="tag"># NIO</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/05/03/Java-NIO-学习之Buffer/" rel="next" title="Java NIO 学习之Buffer">
                <i class="fa fa-chevron-left"></i> Java NIO 学习之Buffer
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/04/24/Java-NIO-学习之背景知识/" rel="prev" title="Java NIO 学习之背景知识">
                Java NIO 学习之背景知识 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8yODI2OC80ODQw"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/gene.png"
               alt="Gene" />
          <p class="site-author-name" itemprop="name">Gene</p>
           
              <p class="site-description motion-element" itemprop="description">A student majoring in Software Engineering</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/iamxpy" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/luo-mu-xue-lan" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-cube"></i>
                  
                  知乎
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/xpy870663266" target="_blank" title="CSDN">
                  
                    <i class="fa fa-fw fa-coffee"></i>
                  
                  CSDN
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/users/1631634e1130/timeline" target="_blank" title="简书">
                  
                    <i class="fa fa-fw fa-book"></i>
                  
                  简书
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#概念与原理"><span class="nav-number">2.</span> <span class="nav-text">概念与原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Scatter-Gather"><span class="nav-number">2.1.</span> <span class="nav-text">Scatter/Gather</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件通道"><span class="nav-number">2.2.</span> <span class="nav-text">文件通道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取通道的几种方法"><span class="nav-number">2.3.</span> <span class="nav-text">获取通道的几种方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件锁定"><span class="nav-number">2.4.</span> <span class="nav-text">文件锁定</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管道Pipe"><span class="nav-number">3.</span> <span class="nav-text">管道Pipe</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Channel通用API"><span class="nav-number">4.</span> <span class="nav-text">Channel通用API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#read-ByteBuffer-dst"><span class="nav-number">4.1.</span> <span class="nav-text">read(ByteBuffer dst)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#read-ByteBuffer-dsts"><span class="nav-number">4.2.</span> <span class="nav-text">read(ByteBuffer[] dsts)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#read-ByteBuffer-dsts-int-offset-int-length"><span class="nav-number">4.3.</span> <span class="nav-text">read(ByteBuffer[] dsts, int offset, int length)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#write-ByteBuffer-src"><span class="nav-number">4.4.</span> <span class="nav-text">write(ByteBuffer src)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#write-ByteBuffer-srcs"><span class="nav-number">4.5.</span> <span class="nav-text">write(ByteBuffer[] srcs)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#write-ByteBuffer-srcs-int-offset-int-length"><span class="nav-number">4.6.</span> <span class="nav-text">write(ByteBuffer[] srcs, int offset, int length)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件通道独有API"><span class="nav-number">5.</span> <span class="nav-text">文件通道独有API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#position"><span class="nav-number">5.1.</span> <span class="nav-text">position()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#position-long-newPosition"><span class="nav-number">5.2.</span> <span class="nav-text">position(long newPosition)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#read-ByteBuffer-dst-long-position"><span class="nav-number">5.3.</span> <span class="nav-text">read(ByteBuffer dst, long position)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#write-ByteBuffer-src-long-position"><span class="nav-number">5.4.</span> <span class="nav-text">write(ByteBuffer src, long position)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#truncate-long-size"><span class="nav-number">5.5.</span> <span class="nav-text">truncate(long size)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#force-boolean-metaData"><span class="nav-number">5.6.</span> <span class="nav-text">force(boolean metaData)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lock-long-position-long-size-boolean-shared"><span class="nav-number">5.7.</span> <span class="nav-text">lock(long position, long size, boolean shared)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lock"><span class="nav-number">5.8.</span> <span class="nav-text">lock()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tryLock-与tryLock-long-position-long-size-boolean-shared"><span class="nav-number">5.9.</span> <span class="nav-text">tryLock()与tryLock(long position, long size, boolean shared)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-MapMode-mode-long-position-long-size"><span class="nav-number">5.10.</span> <span class="nav-text">map(MapMode mode, long position, long size)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#transferTo-和transferFrom"><span class="nav-number">5.11.</span> <span class="nav-text">transferTo()和transferFrom()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FileLock相关API"><span class="nav-number">6.</span> <span class="nav-text">FileLock相关API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#channel"><span class="nav-number">6.1.</span> <span class="nav-text">channel()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#release"><span class="nav-number">6.2.</span> <span class="nav-text">release()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#isValid"><span class="nav-number">6.3.</span> <span class="nav-text">isValid()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#isShared"><span class="nav-number">6.4.</span> <span class="nav-text">isShared()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Socket通道独有API"><span class="nav-number">7.</span> <span class="nav-text">Socket通道独有API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#open"><span class="nav-number">7.1.</span> <span class="nav-text">open()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#open-SocketAddress-remote"><span class="nav-number">7.2.</span> <span class="nav-text">open(SocketAddress remote)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket"><span class="nav-number">7.3.</span> <span class="nav-text">socket()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#accept"><span class="nav-number">7.4.</span> <span class="nav-text">accept()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#configureBlocking-boolean-block"><span class="nav-number">7.5.</span> <span class="nav-text">configureBlocking(boolean block)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#isBlocking"><span class="nav-number">7.6.</span> <span class="nav-text">isBlocking()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#blockingLock"><span class="nav-number">7.7.</span> <span class="nav-text">blockingLock()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#connect-SocketAddress-remote"><span class="nav-number">7.8.</span> <span class="nav-text">connect(SocketAddress remote)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#isConnected"><span class="nav-number">7.9.</span> <span class="nav-text">isConnected()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#isConnectPending"><span class="nav-number">7.10.</span> <span class="nav-text">isConnectPending()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#finishConnect"><span class="nav-number">7.11.</span> <span class="nav-text">finishConnect()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#send-ByteBuffer-src-SocketAddress-target"><span class="nav-number">7.12.</span> <span class="nav-text">send(ByteBuffer src, SocketAddress target)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#receive-ByteBuffer-dst"><span class="nav-number">7.13.</span> <span class="nav-text">receive(ByteBuffer dst)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#disconnect"><span class="nav-number">7.14.</span> <span class="nav-text">disconnect()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pipe类API"><span class="nav-number">8.</span> <span class="nav-text">Pipe类API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#open-1"><span class="nav-number">8.1.</span> <span class="nav-text">open()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#source"><span class="nav-number">8.2.</span> <span class="nav-text">source()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sink"><span class="nav-number">8.3.</span> <span class="nav-text">sink()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Channels类API"><span class="nav-number">9.</span> <span class="nav-text">Channels类API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#newChannel-InputStream-in"><span class="nav-number">9.1.</span> <span class="nav-text">newChannel(InputStream in)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#newChannel-OutputStream-out"><span class="nav-number">9.2.</span> <span class="nav-text">newChannel(OutputStream out)</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gene</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  








  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("kqHYy2W6o1QD5K0EKWE0zdPy-gzGzoHsz", "lLFeuDQsMSkp011HnWxTfaH1");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

</body>
</html>
